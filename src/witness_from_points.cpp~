// #include <gudhi/Simplex_tree.h>
// #include <gudhi/Euclidean_witness_complex.h>
// #include <gudhi/pick_n_random_points.h>
// #include <gudhi/Points_off_io.h>
// #include <CGAL/Epick_d.h>
// #include <string>
// #include <vector>

#include <gudhi/Alpha_complex.h>
// to construct a simplex_tree from alpha complex
#include <gudhi/Simplex_tree.h>
#include <CGAL/Epick_d.h>
#include <iostream>
#include <string>
#include <vector>
#include <limits>  // for numeric limits

#include <Rcpp.h>
using namespace Rcpp;
//using SimplexTree = Gudhi::Simplex_tree<>;

// typedef CGAL::Epick_d<CGAL::Dynamic_dimension_tag> K;
// typedef typename K::Point_d Point_d;
// typedef typename Gudhi::witness_complex::Euclidean_witness_complex<K> Witness_complex;
// //typedef std::vector< Vertex_handle > typeVectorVertex;
// typedef std::vector< Point_d > Point_vector;



using Kernel = CGAL::Epick_d<CGAL::Dynamic_dimension_tag>;
//using Kernel = CGAL::Epick_d< CGAL::Dimension_tag<3> >;
using Point = Kernel::Point_d;
using Vector_of_points = std::vector<Point>;

// [[Rcpp::export]]

SEXP witness_from_points(const Rcpp::List landmarksin){
  
  Gudhi::Simplex_tree<> simplex_tree;
  Vector_of_points point_vector, landmarks_vector;
  
  
  for (int i=0;i<landmarksin.size();++i){
    std::vector<double> lm=landmarksin[i];
    landmarks_vector.push_back(lm);
  }

  

}

