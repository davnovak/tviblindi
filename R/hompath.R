make_circle_n<-function(n,r=1,sd=0.1,shift=c(0,0)){
    XX <- circleUnif(n,r)+cbind(rnorm(n,sd=sd),rnorm(n,sd=sd))
    XX<-t(t(XX)+shift)
}

#' Create a synthetic snowman dataset
#'
#' \code{make_snowman} outputs a matrix of coordinates in a space of dimension 2. When plotted, the points approximate the shape of a snowman, consisting of three circular segments. This is intended as test data for topological analysis.
#' See vignette of package \code{tviblindi} for a demonstration of use.
#'
#' @param N number of points in a single segment of the snowman. (Since the bottom part of the snowman is cut off, total number of points will be around 2.5 times \code{N}).
#'
#' @return A matrix of coordinates. Rows correspond to points.
#'
#' @export
make_snowman<-function(N){
    XX<-rbind(make_circle_n(N,r=0.25,sd=0.05,shift=c(0,3)),make_circle_n(N,sd=0.2),make_circle_n(N,r=0.7,sd=0.1,shift=c(0,2)))
    XX<-XX[-which(XX[,2]<0),]
}

make_snowman3d<-function(N){
    XX<-rbind(cbind(make_circle_n(N,r=0.25,sd=0.05,shift=c(0,3)),rnorm(N,sd=0.05)),cbind(make_circle_n(N,sd=0.2),rnorm(N,sd=0.2)),cbind(make_circle_n(N,r=0.7,sd=0.1,shift=c(0,2)),rnorm(N,sd=0.1)))
    XX<-rbind(XX,cbind(rnorm(N,sd=0.05),make_circle_n(N,r=0.25,sd=0.05,shift=c(3,0))),cbind(rnorm(N,sd=0.2),make_circle_n(N,sd=0.2)),cbind(rnorm(N,sd=0.1),make_circle_n(N,r=0.7,sd=0.1,shift=c(2,0))))
    XX<-XX[-which(XX[,2]<0),]
}
make_graph_XX<-function(XX,K=5){
    g<-knn.spadj2sym(knn.adj2spadjsim(knn.adj.construct(XX,K)))
    res<-assign_distance(g,origin=1)
    g<-remove_back_R(sparse2triples(g),res$res)
    g<-sparseMatrix(i=g$from,j=g$to,x=g$weight,dims=c(nrow(XX),nrow(XX)))
    ##g<-graph_from_adjacency_matrix(g,weighted = TRUE,mode="directed")

}

make_graph_XX_sym<-function(XX,K=5){
    g<-knn.spadj2sym(knn.adj2spadjsim(knn.adj.construct(XX,K)))
    res<-assign_distance(g,origin=1)
    g<-sparse2triples(g)
    g<-sparseMatrix(i=g$from,j=g$to,x=g$weight,dims=c(nrow(XX),nrow(XX)))
    ##g<-graph_from_adjacency_matrix(g,weighted = TRUE,mode="directed")

}


sample_walks<-function(g,n=10) random_walk_adj_N(g,1,1000,n)

#' Plot simulated random walks
#'
#' \code{plot_walks} plots simulated random walks, provided coordinates of vertices and walks through a graph containing the vertices. These walks are typically generated by the function \code{random_walk}.
#'
#' @param XX matrix of vertex coordinates, with rows corresponding to vertices.
#' @param walks object specifying walks through the graph containing vertices, as specified by \code{XX}. As generated by \code{random_walk}.
#' @param sel vector containing indices of selected walks to be plotted. Defaults to all walks.
#' @param col vector of numeric colour codes for plotting. Defaults to numbers of each walk in the \code{walks} object.
#' @param Xmap optional vector which maps numbers in \code{walks$v} to row indices of \code{XX}.
#' @param ... additional parameters passed to \code{lines} function used for plotting walks.
#'
#' @export
plot_walks<-function(XX,walks,sel=1:length(walks$starts),col=1:length(walks$starts),Xmap=NULL,...) {
    plot(XX)
    j<-0
    if (is.null(Xmap)) for (i in sel) { j<-j+1; lines(XX[select_paths_points(walks,i),],lty=1,col=col[j],...) } else for (i in sel) { j<-j+1; lines(XX[Xmap[select_paths_points(walks,i)],],lty=1,col=col[j],...) }
}

#' Select unique points
#'
#' \code{select_unique_points} requires a vector of points (i.e. vertex indices) and a coordinate matrix. The function returns a list including
#'  indices of unique points and original coordinates.
#'
#' @param XX matrix of vertex coordinates, with rows corresponding to vertices.
#' @param sel vector of points (i.e. row indices of \code{XX}).
#'
#' @return \code{select_unqiue_points} returns a list containing the following elements. \code{X} is the original matrix of coordinates (\code{XX}). \code{map}
#'  is a numeric vector containing indices of unique entries in \code{sel}.
#'
#' @export
select_unique_points<-function(XX,sel){
    sel <- sort(sel)
    sel <- cbind(sel, as.numeric(as.factor(sel)))
    sel <- sel[-which(duplicated(sel[,1])),]
    map <- rep(0, nrow(XX))
    map[sel[,1]] <- sel[,2]
    return(list(X=XX[sel[,1],], map=map))
}

hash_cmplx<-function(cmplx){
    hash<-new.env(hash=TRUE)
    for (i in 1:length(cmplx)){

        if (length(cmplx[[i]])==2){
            assign(paste(cmplx[[i]],collapse = "_"),i,envir=hash)
            assign(paste(rev(cmplx[[i]]),collapse = "_"),i,envir=hash)
        }
    }
    hash$Nsimplices<-length(cmplx)
    return(hash)
}


keys<-function(x) ls(x,all.names = TRUE)

clear<-function(x) rm(list=keys(x), envir=x)

path_keys<-function(v){
    v<-cbind(v[-length(v)],v[-1])
    sel<-which(v[,2]==v[1])
    if (length(sel)>0) v<-v[-sel]
    paste(v[,1],v[,2],sep="_")
}

## hash_path<-function(v){
##     keys<- paste(v[-length(v)],v[-1],sep="_")
##     values<-cbind(v[-length(v)],v[-1])
##     sel<-which(duplicated(keys))
##     if (length(sel)>0){keys<-keys[-sel];values<-values[-sel,]}
##     hash<-new.env(hash=TRUE)
##     for (i in 1:length(keys)){
##         assign(keys[i],values[i,],envir=hash)
##     }
##     return(hash)
## }

## augment_filtration<-function(cmplx,v,X,K=30){
##     oneC<-rep(FALSE,length(cmplx))
##     keysC<-rep("",2*length(cmplx))
##     vs<-0
##     for (i in 1:length(cmplx)){
##         if (length(cmplx[[i]])==1) vs<-vs+1
##         if(length(cmplx[[i]])==2){
##             oneC[i]<-TRUE
##             keysC[i]<-paste(cmplx[[i]],collapse = "_")
##             keysC[2*i]<-paste(rev(cmplx[[i]]),collapse = "_")
##         }

##     }
##     oneC<-which(oneC)
##     cmplx<-cmplx[oneC]

##     keysv<-paste(v[-length(v)],v[-1])
##     values<-cbind(v[-length(v)],v[-1])
##     sel<-which(values[,2]==v[1])
##     if (length(sel)>0){keysv<-keysv[-sel];values<-values[-sel,]}
##     sel<-which(duplicated(keysv))
##     if (length(sel)>0){keysv<-keysv[-sel];values<-values[-sel,]}
##     ## hc<-hash_cmplx(cmplx)
##     toAdd<-which(!(keysv %in% keysC))
##     toAdd<-as.list(as.data.frame(t(values[toAdd,])))

##     names(toAdd)<-NULL
##     ## clear(hc)
##     ## rm(hc)
##     cmplx<-c(cmplx,toAdd)
##     g<-graph_from_edgelist(do.call("rbind",cmplx))
##     ## print(length(V(g)))
##     ## for (i in 1:length(V(g))){
##     ##     e1<-ego(graph=g,nodes=i,order=1)[[1]]
##     ##     print(length(e1))
##     ##     e2<-ego(graph=g,nodes=i,order=2)[[1]]
##     ##     print(length(e2))
##     ##     e2<-setdiff(e2,e1)
##     ##     print(length(e2))
##     ##     print("___")

##     ##     if (length(e2)==0) break
##     ##     e1<-rep(i,2*length(e2))
##     ##     ss<-seq(2,length(e1),by=2)
##     ##     e1[ss]<-e2
##     ##     g<-add_edges(graph = g,edges=e1)

##     ## }
##     print(length(E(g)))
##     tt<-as.list(as.data.frame(t(matrix(triangles(g),ncol=3,byrow=TRUE))))
##     names(tt)<-NULL
##      cmplx<-c(cmplx,tt)
##     fVal<-c(rep(0,vs),filter_values(X,cmplx,K))
##     cmplx<-c(1:vs,cmplx)
##     ord<-order(fVal)


##     return(list(cmplx=cmplx[ord],values=fVal[ord],increasing=TRUE))


## }

filter_values_f<-function(X,cmplx,K=30){
    ##dX<-knn.spadj2sym(knn.adj2spadj(knn.adj.construct(X,K)))
    out<-rep(0,length(cmplx))
    for (i in 1:length(cmplx)){
        if (i %% 10000 ==0) print(i)
        if (length(cmplx[[i]])==2){
            ## out[i]<-dX[cmplx[[i]][1],cmplx[[i]][2]]
            ## if (out[i]==0) out[i]<-as.numeric(dist(X[cmplx[[i]],]))
            out[i]<-as.numeric(dist(X[cmplx[[i]],]))
        } else if (length(cmplx[[i]])==3){

            out[i]<-max(out[cmplx[[i]]])+0.0000001
        }
    }
    out
}

filter_values<-function(X,cmplx,K=30){
    dX<-knn.spadj2sym(knn.adj2spadj(knn.adj.construct(X,K)))
    out<-rep(0,length(cmplx))
    for (i in 1:length(cmplx)){
        if (i %% 10000 ==0) print(i)
        if (length(cmplx[[i]])==2){
            out[i]<-dX[cmplx[[i]][1],cmplx[[i]][2]]
            if (out[i]==0) out[i]<-as.numeric(dist(X[cmplx[[i]],]))
        } else if (length(cmplx[[i]])==3){
            ii<-cmplx[[i]]
            ii<-rbind(c(ii[1],ii[2]),c(ii[2],ii[3]),c(ii[3],ii[1]))

            if (min(dX[ii[,1],ii[,2]])>0){
                outi<-max(dX[ii[,1],ii[,2]])

            }  else {

                outi<-max(as.matrix(dist(X[cmplx[[i]],])))

            }
            out[i]<-outi+0.0000001
            if (out[i]==0) out[i]<-Inf
        }
    }
    out
}

## plot_1cmplx<-function(X,cmplx,col=NULL,...){
##     plot(X,pch=".")
##     cc<-rep(1,length(cmplx))
##     if (!is.null(col)) cc[col]<-2
##     for (i in 1:length(cmplx)){
##         if(length(cmplx[[i]])==2){
##             lines(X[cmplx[[i]],],col=cc[i],...)

##         }
##     }
## }

plot_2cmplx<-function (X, cmplx, col = NULL,add=FALSE)
{
  if (!add) plot(X, pch = ".")
  cc <- rep(1, length(cmplx))
  lty <- rep(2, length(cmplx))
  if (!is.null(col))
    cc[col] <- 2
  if (!is.null(col))
    lty[col] <- 1
  for (i in 1:length(cmplx)) {
    if (length(cmplx[[i]]) == 3 & cc[i] != 1) {

      lines(X[cmplx[[i]][1:2], ], col = cc[i], lwd = cc[i],
            lty = lty[i])

      lines(X[cmplx[[i]][2:3], ], col = cc[i], lwd = cc[i],
            lty = lty[i])

      lines(X[cmplx[[i]][c(3, 1)], ], col = cc[i], lwd = cc[i],
            lty = lty[i])
    }
  }
}

plot_1cmplx<-function (X, cmplx,add=FALSE,col=2,...)
{
  if (!add) plot(X,pch=".",...)
  for (i in 1:length(cmplx)) {
    if (length(cmplx[[i]]) == 2) {
      lines(X[cmplx[[i]], ],col=col,lwd=2)
    }
  }
}


## plot_2cmplx<-function(X,cmplx,col=NULL){
##     plot(X,pch=".")
##     cc<-rep(1,length(cmplx))
##     lty<-rep(2,length(cmplx))
##     if (!is.null(col)) cc[col]<-2
##     if (!is.null(col)) lty[col]<-1
##     for (i in 1:length(cmplx)){
##         if(length(cmplx[[i]])==3 & cc[i]!=1){
##             lines(X[cmplx[[i]][1:2],],col=cc[i],lwd=cc[i],lty=lty[i])
##             lines(X[cmplx[[i]][2:3],],col=cc[i],lwd=cc[i],lty=lty[i])
##             lines(X[cmplx[[i]][c(3,1)],],col=cc[i],lwd=cc[i],lty=lty[i])

##         }
##     }

## }



build_boundary_R<-function(cmplx){
    hc<-hash_cmplx(cmplx)

    N<-length(cmplx)
    low<-rep(0,N)
    boundary<-sparseMatrix(i=NULL,j=NULL,dims=c(N,N))
    for (i in 1:N){
         if (i %% 1000 == 0) print(i)
        if (length(cmplx[[i]])==2){
            boundary[cmplx[[i]],i]<-TRUE
            low[i]<-max(low[i],cmplx[[i]])
        } else if(length(cmplx[[i]])==3){

            boundary[hc[[paste(cmplx[[i]][1:2],collapse="_")]],i]<-TRUE
            boundary[hc[[paste(cmplx[[i]][2:3],collapse="_")]],i]<-TRUE
            boundary[hc[[paste(cmplx[[i]][c(3,1)],collapse="_")]],i]<-TRUE
            low[i]<-max(low[i],hc[[paste(cmplx[[i]][c(3,1)],collapse="_")]],hc[[paste(cmplx[[i]][2:3],collapse="_")]],hc[[paste(cmplx[[i]][1:2],collapse="_")]])
        }
    }
    clear(hc)
    rm(hc)
    list(boundary=boundary,low=low)
}

build_boundary<-function(cmplx){
    vals<-cmplx$values
    cmplx<-cmplx$cmplx
    ll<-unlist(lapply(cmplx,length))
    ## message("lenghth")
    ssC<-which(ll<=3) #2-skeleton
    vals<-vals[ssC]
    cmplx<-cmplx[ssC]
    hc<-hash_cmplx(cmplx)
    ## message("hash")
    N<-length(cmplx)
    ## message(N)
    for (i in 1:N){
         if (i %% 100000 == 0) print(i)
         if(length(cmplx[[i]])==3){
             ## print(paste(cmplx[[i]][1:2],collapse="_"))
             ## print(hc[[paste(cmplx[[i]][1:2],collapse="_")]])
             loc<-c(hc[[paste(cmplx[[i]][1:2],collapse="_")]],hc[[paste(cmplx[[i]][2:3],collapse="_")]],hc[[paste(cmplx[[i]][c(3,1)],collapse="_")]])
             cmplx[[i]]<-loc
         }
         cmplx[[i]]<-sort(cmplx[[i]])-1
    }
    clear(hc)
    rm(hc)
    return(list(cmplx=cmplx,values=vals))

}

build_boundary_reval<-function(cmplx,X){
    vals<-cmplx$values
    cmplx<-cmplx$cmplx
    ll<-unlist(lapply(cmplx,length))
    ## message("lenghth")
    ssC<-which(ll<=3) #2-skeleton
    vals<-vals[ssC]
    cmplx<-cmplx[ssC]
    hc<-hash_cmplx(cmplx)
    ## message("hash")
    N<-length(cmplx)
    ## message(N)
    for (i in 1:N){
        if (i %% 100000 == 0) print(i)
        if (length(cmplx[[i]])==2){
            vals[i]<-as.numeric(dist(X[cmplx[[i]],]))
        }
         if(length(cmplx[[i]])==3){
             ## print(paste(cmplx[[i]][1:2],collapse="_"))
             ## print(hc[[paste(cmplx[[i]][1:2],collapse="_")]])
             loc<-c(hc[[paste(cmplx[[i]][1:2],collapse="_")]],hc[[paste(cmplx[[i]][2:3],collapse="_")]],hc[[paste(cmplx[[i]][c(3,1)],collapse="_")]])
             cmplx[[i]]<-loc
             vals[i]<-max(out[cmplx[[i]]])+0.0000001
         }
         cmplx[[i]]<-sort(cmplx[[i]])-1
    }
    clear(hc)
    rm(hc)
    return(list(cmplx=cmplx,values=vals))

}

reduce_boundary_R<-function(boundary){
    low<-boundary$low
    boundary<-boundary$boundary
    N<-dim(boundary)[1]
     V<-matrix(0,ncol=N,nrow=N)
    diag(V)<-1
    for (j in 1:N){
        if (j %% 1000 == 0) print(j)
        if (low[j]>0){
            sel<-which(head(low,n=j-1)==low[j])

            while(length(sel)>0){
                if (j==25) print(sel[1])
                boundary[,j]<-xor(boundary[,j],boundary[,sel[1]])
                low[j]<-max(0,which(boundary[,j]))
                V[sel[1],j]<- (V[sel[1],j]+1)
                if (low[j]==0) break
                sel<-which(head(low,n=j-1)==low[j])
            }
        }
    }
    list(boundary=boundary,low=low,V=V)
}

## get_representation_R<-function(cycle,boundary){
##     low<-boundary$low
##     ss<-which(low>0)
##     Ilow<-rep(0,max(low))
##     Ilow[low[ss]]<-ss

##     boundary<-boundary$boundary
##     repre<-NULL

##     ll<-max(Matrix::which(cycle))
##     while(ll>0){
##         rr<-Ilow[ll]
##         ##print(cycle)
##         ##print(which(cycle))
##         if (rr==0)  stop("not a cycle?")
##         cycle<-xor(boundary[,rr],cycle)

##         ##print(cycle)
##         repre<-c(repre,rr)
##         ll<-max(Matrix::which(cycle))

##     }
##     repre
## }

path_sum_R<-function(path1,path2,Nc){
    xor(sparseVector(i=path1,length=Nc,x=TRUE),sparseVector(i=path2,length=Nc,x=TRUE))

}

graph_to_1simplices<-function(g){
    g<-as.matrix(summary(as_adjacency_matrix(g)))
    colnames(g)<-NULL
    zero<-sort(unique(c(g[,1],g[,2])))
    gl<-split(g, seq(nrow(g)))
    names(gl)<-NULL
    return(list(cmplx=c(zero,gl),gl,values=c(rep(0,length(zero)),g[,3])))
}

sparseadj_to_1simplices<-function(g){
    g<-as.matrix(summary(Matrix::triu(g)))
    ##g<-as.matrix(summary(g))
    colnames(g)<-NULL
    zero<-sort(unique(c(g[,1],g[,2])))
    gl<-split(g[,1:2], seq(nrow(g)))
    names(gl)<-NULL
    return(list(cmplx=c(zero,gl),gl,values=c(rep(0,length(zero)),g[,3])))
}

index_path<-function(walks,cmplx){
    ss<-which(unlist(lapply(cmplx,FUN=function(x) return(length(x)==2))))
    cmplx<-cmplx[ss]
    hc<-hash_cmplx(cmplx)
    N<-length(walks$starts)
    outL<-list()[1:N]
    for (i in 1:N){
        out<-NULL
        v<-select_paths_points(walks,i)
        keysv<-paste(v[-length(v)],v[-1],sep="_")
        for (j in 1:length(keysv)){
            ind<-hc[[keysv[j]]]
            out<-c(out,ind)
        }
        outL[[i]]<-ss[out]

    }
    return(outL)
}

## path_triangulation_R<-function(v,cmplx,X){
##     hc<-hash_cmplx(cmplx)
##     ss<-which(unlist(lapply(cmplx,FUN=function(x) return(length(x)==2))))

##     edges<-do.call("rbind",lapply(cmplx[ss],FUN=function(sim,XX) return(c(sim,dist(X[sim,]))),XX=X))
##     colnames(edges)<-c("from","to","weight")
##     g<-graph_from_edgelist(edges[,1:2])
##     E(g)$weight<-edges[,3]
##     keysv<-paste(v[-length(v)],v[-1],sep="_")
##     values<-cbind(v[-length(v)],v[-1])
##     out<-NULL
##     for (i in 1:nrow(values)){
##         ind<-hc[[keysv[i]]]
##         if (!is.null(ind)){
##             out<-c(out,ind)
##             next
##         }
##         ind<-as.integer(shortest_paths(g,from=values[i,1],to=values[i,2],mode="all",output = "epath")$epath[[1]])
##         out<-c(out,ss[ind])

##     }
##     clear(hc)
##     rm(hc)
##     tt<-table(out)

##     ss<-which(tt %% 2 == 0)

##     if (length(ss)>0) {
##         ss<-which(out %in% as.integer(names(tt[ss])))
##         out<-out[-ss]
##     }
##     return(unique(out))

## }

#' Generate a reduced boundary matrix object
#'
#' \code{reduce_boundary} generates a compact representation of a reduced boundary matrix, produced from a boundary matrix object, as generated by \code{build_boundaryC}.
#'
#' @param boundary boundary matrix object, as generated by \code{build_boundaryC}.
#'
#' @return
#' \code{reduce_boundary} returns a list containing the following elements.
#'
#' \code{boundary} is a list indexed by simplex numbers, containing vectors of respective boundary simplices.
#'
#' \code{nonzero_col} is a vector containing indices of non-zero columns of a reduced boundary matrix.
#'
#' \code{low} is a vector containing indices of the lowest non-zero entry row for all non-zero columns of the reduced boundary matrix.
#'
#' \code{dim} is a vector containing the dimension of each complex represented by a non-zero column.
#'
#' \code{values} is a vector of filtration values.
#'
#' @export
reduce_boundary<-function(boundary){
    values<-boundary$values
    boundary$cmplx <- lapply(boundary$cmplx,function(x) if (length(x)==0) return(integer(0)) else return(x-1))
    boundary<-phatBoundary(boundary,1)
    boundary$values<-values
    return(boundary)
}

#' Get representation cycle representation in terms of simplicial complexes
#'
#' \code{get_rep} generates representation of a cycle in terms of complexes created during filtration, using a reduced boundary matrix object, as generated
#'  by \code{reduce_boundary}. The sum of these complexes (effectively a symmetric difference) is the cycle.
#'
#' @param cycle n-simplex indices forming a cyclical n-chain.
#' @param boundary reduced boundary matrix object, as generated by \code{reduce_boundary}.
#'
#' @return \code{get_rep} returns a vector of column indices of \code{boundary}.
#'
#' @export
get_rep <- function(cycle, boundary) {
  return(get_rep_C(cycle, boundary))
}

get_representation<-function(cycle,boundary){
    low<-boundary$low
    nzc<-boundary$nonzero_col
    ss<-1:length(boundary$nonzero_col)
    Ilow<-rep(0,max(cycle))
    Ilow[low]<-ss
    boundary<-boundary$boundary
    repre<-NULL

    ll<-max(cycle)
    print(ll)
    while(ll>-Inf){
        rr<-Ilow[ll]
        if (rr==0)  stop("not a cycle?")
        cycle<-symdiff(boundary[[rr]],cycle)
        repre<-c(repre,nzc[rr])
        ll<-max(cycle)
    }
    repre
}

path_sum<-function(path1,path2){
    symdiff(path1,path2)

}

symdiff <- function( x, y) { setdiff( union(x, y), intersect(x, y))}

## path_triangulation_1<-function(v,cmplx,X){
##     hc<-hash_cmplx(cmplx)
##     ss<-which(unlist(lapply(cmplx,FUN=function(x) return(length(x)==2))))

##     edges<-do.call("rbind",lapply(cmplx[ss],FUN=function(sim,XX) return(c(sim,dist(X[sim,]))),XX=X))
##     colnames(edges)<-c("from","to","weight")
##     g<-graph_from_edgelist(edges[,1:2])
##     E(g)$weight<-edges[,3]
##     keysv<-paste(v[-length(v)],v[-1],sep="_")
##     values<-cbind(v[-length(v)],v[-1])
##     out<-NULL
##     for (i in 1:nrow(values)){
##         ind<-hc[[keysv[i]]]
##         if (!is.null(ind)){
##             out<-c(out,ind)
##             next
##         }
##         ind<-as.integer(shortest_paths(g,from=values[i,1],to=values[i,2],mode="all",output = "epath")$epath[[1]])
##         out<-c(out,ss[ind])

##     }
##     clear(hc)
##     rm(hc)
##     tt<-table(out)

##     ss<-which(tt %% 2 == 0)

##     if (length(ss)>0) {
##         ss<-which(out %in% as.integer(names(tt[ss])))
##         out<-out[-ss]
##     }
##     return(sort(unique(out)))

## }

onepath_triangulation<-function(v,X,hc,g){
    keysv<-paste(v[-length(v)],v[-1],sep="_")
    values<-cbind(v[-length(v)],v[-1])
    out<-NULL
    for (i in 1:nrow(values)){
        ind<-hc[[keysv[i]]]
        if (!is.null(ind)){
            out<-c(out,ind)
            next
        }
        ind<-as.integer(shortest_paths(g,from=values[i,1],to=values[i,2],mode="all",output = "epath")$epath[[1]])
        out<-c(out,ind)
    }
    tt<-table(out)

    ss<-which(tt %% 2 == 0)

    if (length(ss)>0) {
        ss<-which(out %in% as.integer(names(tt[ss])))
        out<-out[-ss]
    }
    return(sort(unique(out)))

}

#' Generate triangulated paths
#'
#' \code{path_triangulation} re-creates random walks, as generated by \code{random_walk}, using 1-simplices generated by a filtration function.
#'  Thus, the original paths are converted into 1-chains
#'  which approximate them and represent their topology. Since all vertices from the original path must be included, the triangulated path must be of same or greater length.
#'  Connections between each pair of points are found in terms of 1-simplices via uniform-cost search.
#'
#' @param walks object specifying walks through the graph containing vertices, as specified by \code{X}. As generated by \code{random_walk} or of the same format.
#' @param X matrix of vertex coordinates, with rows corresponding to vertices.
#' @param cmplx simplicial complex, as generated by a filtration function, such as \code{alphaComplexFiltration}.
#' @param sel vector containing indices of selected walks.
#'
#' @return \code{path_triangulation} returns a list of point (vertex) indices.
#'
#' @export
path_triangulation<-function(walks,X,cmplx,sel){
    ss<-which(unlist(lapply(cmplx,FUN=function(x) return(length(x)<=3)))) #if original cmplx!!
    cmplx<-cmplx[ss]
    Xmap<-X$map
    X<-X$X
    ss<-which(unlist(lapply(cmplx,FUN=function(x) return(length(x)==2))))
    cmplx<-cmplx[ss]
    hc<-hash_cmplx(cmplx)
    edges<-do.call("rbind",lapply(cmplx,FUN=function(sim,XX) return(c(sim,dist(X[sim,]))),XX=X))
    colnames(edges)<-c("from","to","weight")
    g<-graph_from_edgelist(edges[,1:2])
    E(g)$weight<-edges[,3]
    out<-list()[1:length(sel)]
    j<-0
    for (i in sel){
        j<-j+1
        out[[j]]<-ss[onepath_triangulation(Xmap[select_paths_points(walks,i)],X,hc,g)]
    }
    clear(hc)
    rm(hc)
    return(out)
}

#' Create persistence diagram
#'
#' \code{pers_diagram} computes persistence and creates a persistence diagram given a reduced boundary matrix object, as generated by
#'  \code{reduce_boundary}.
#'
#' @param dBr reduced boundary matrix object, as generated by \code{reduce_boundary}.
#' @param plot Boolean, plot persistence diagram? Defaults to \code{TRUE}.
#'
#' @return
#' \code{pers_diagram} returns a list containing the following elements.
#'
#' \code{inds} is a matrix describing homology classes by dimension, index of simplex which caused birth of the class and index of simplex which caused death of the class.
#'
#' Analogically, \code{vals} describes homology classes by dimension, filtration value corresponding to birth and filtration value corresponding to death.
#'
#' @export
pers_diagram<-function(dBr,plot=TRUE){
    ss<-which(dBr$values[dBr$low]!=dBr$values[dBr$nonzero_col])
    if (plot) plot(dBr$values[dBr$nonzero_col[ss]]~dBr$values[dBr$low[ss]],col=dBr$dim[ss]+1,pch=dBr$dim[ss]+1)
    return(list(inds=data.frame(dim=dBr$dim[ss],birth=dBr$low[ss],death=dBr$nonzero_col[ss]),vals=data.frame(dim=dBr$dim[ss],birth=dBr$values[dBr$low[ss]],death=dBr$values[dBr$nonzero_col[ss]])))
}


