#' Select a subset of path points
#'
#' \code{select_paths_points} returns a subset of points on walks from an object generated by \code{random_walk}.
#'
#' @param paths output of \code{random_walk}.
#' @param sel vector of numbers of walks to be selected.
#'
#' @return \code{select_paths_points} returns a vector of vertex indices in selected walks.
#'
#' @export
select_paths_points<-function(paths,sel){
    ## out<-NULL

    if (any(sel==length(paths$starts))) esel<-which(sel==length(paths$starts)) else esel<-NULL
    if (!is.null(esel)) {sel1<-sel[-esel];esel<-sel[esel]} else sel1<-sel
    starts<-c(paths$starts[sel1],paths$starts[esel])
    ends<-c(paths$starts[sel1+1]-1,rep(length(paths$v),length(esel)))

    ss<-unlist(apply(cbind(starts,ends),MARGIN=1, FUN=function(x) seq(x[1],x[2],1)))


    out<-paths$v[ss]
    return(out)


  ## for (i in sel){
  ##   if (i<length(paths$starts)) out<-c(out,paths$v[paths$starts[i]:(paths$starts[i+1]-1)]) else out<-c(out,paths$v[paths$starts[i]:(length(paths$v))])
  ## }
  ## return(unique(out))
}

## sp_or<-function(paths,sel){
##   out<-NULL
##   for (i in sel){
##     if (i<length(paths$starts)) out<-c(out,paths$v[paths$starts[i]:(paths$starts[i+1]-1)]) else out<-c(out,paths$v[paths$starts[i]:(length(paths$v))])
##   }
##   return((out))
## }

path_neighborhood<-function(vertices,graph,thresh=1){
    out<-NULL
    pathW<-E(graph,path=vertices)$weight
    N<-length(vertices)
    for (i in 1:N){
        neighb_i<-ego(graph,nodes=vertices[i])[[1]][-1]
        ve<-rep(vertices[i],2*length(neighb_i))
        ss<-which((1:length(ve)) %% 2 == 0)
        ve[ss]<-neighb_i
        if (i == 1) prah<-thresh*pathW[1] else if (i==N) prah<-thresh*pathW[N-1] else prah<-thresh*0.5*(pathW[i-1]+pathW[i])
        Ew<-E(graph,P=ve)$weight
        ss<-which(Ew<=prah)
        out<-c(out,vertices[i],neighb_i[ss])

    }
    return(unique(out))

}


## plot_1cmplx<-function(X,cmplx){
##     plot(X)
##     for (i in 1:length(cmplx)){
##         if(length(cmplx[[i]])==2){
##             lines(X[cmplx[[i]],])

##         }
##     }
## }

#' Contract walks to cluster nodes
#'
#' \code{contract_walks} returns a walks with vericies contracted to cluster nodes from an object generated by \code{random_walk}.
#'
#' @param walks output of \code{random_walk}.
#' @param cluster vector of cluster assignement of the original pointcloud.
#'
#' @return \code{contract_wlaks} returns a list of vertex indices and indices of walks starts.
#'
#' @export
contract_walks <- function(walks, clusters) {
  contracted <- list()
  for (i in 1:length(walks$starts)) {
    w <- select_paths_points(walks, i)

    edges <- lapply(1:(length(w) - 1), function(j, k = j + 1) clusters[w[j:k]]) # walk as list of edges (using cluster numbering)
    edges <- edges[lapply(edges, function(j) j[1] != j[2]) %>% unlist] # remove edges leading to self

    w <- c(
      edges[[1]][1],
      unlist(lapply(edges, function(i) i[2]))
    )
    contracted[[i]] <- w
  }

  starts <- c(1, unlist(lapply(contracted, length)))
  starts <- starts[-length(starts)]
  starts <- sapply(1:length(starts), function(i) sum(starts[1:i]))

  list(v = unlist(contracted), starts = starts)
}
